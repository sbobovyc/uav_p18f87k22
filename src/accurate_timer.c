/**
 * This uses Timer0, 16 bit, for accurate timing. 
 * @file accurate_timer.c
 * @author Stan Bobovych
 */

#include <timers.h>
#include <stdio.h>

int timer_rollover = 0;

//----------------------------------------------------------------------------
// High priority interrupt routine
#pragma code
#pragma interrupt InterruptHandlerHigh

void
InterruptHandlerHigh ()
{ //Every 0.026 secs
   if (INTCONbits.TMR0IF)
   { 
		//check for TMR0 overflow
		INTCONbits.TMR0IF = 0; //clear interrupt flag
      	WriteTimer0(0);
      	//Code used by the interrupt goes here
	  	timer_rollover++;
   }
}

#pragma code InterruptVectorHigh = 0x08
void
InterruptVectorHigh (void)
{
  _asm
   goto InterruptHandlerHigh //jump to interrupt routine
  _endasm
}

//-----------------
// End of interrupt handlers


void timer_init(void)
{
    INTCONbits.GIEH = 1; //enable interrupts
	WriteTimer0(0); //zero out timer
}

void timer_start(void)
{
	    OpenTimer0(TIMER_INT_ON & T0_16BIT & T0_SOURCE_INT & T0_PS_1_1); 
}
void timer_stop(void)
{
	CloseTimer0();
}

void timer_clear()
{
	WriteTimer0(0); //zero out timer
	timer_rollover = 0; // zero the roll over
}

//TODO: Unsure if the numbers generated by this function will ever get big enough to use a long, may need to switch to regular int
int timer_getOutput() 
{
	int tmp;

	if(timer_rollover == 0)
		tmp = ReadTimer0()-13; //overhead of using this timer is 13 cycles
	else
		tmp = ( ReadTimer0() - 13) + 65536 * timer_rollover; //overhead of using this timer is 13 cycles
	//printf("Timer %i \r\n", tmp);
	return tmp;
}

